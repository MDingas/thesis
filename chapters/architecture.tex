\chapter{System Architecture and Developed Mechanisms}

    As the main proposed goal of this work is the implementation of a system that complies with the \gls{alto} working group's devised protocol, this chapter exhibits the planned software specifications needed to implement the system as a whole, with the aforementioned protocol being a crucial part of client-server resource exchange.

    Initial attention is given to the general architecture on the first section, with the goal of identifying key entities, their purpose, and how they interact among themselves.
    The following section will target the specification of \gls{alto} resources, which can be considered the driving force behind the system, as they are what the client entities seek, and likewise what the \glspl{isp} wish to provide.
    The next section will focus on specifying the task of network status provisioning to an appropriate \gls{alto} server, in such a way that a common interface exists among all entities that are able to increase the server's knowledge of the network's physical topology.
    Upon specified the way that network information is provided, the next section details how a given actor, such as an \gls{isp} administrator, can pre-process such information before it is forwarded to the server and available to clients.
    Finally, the task of multi-domain \gls{alto} server synchronization and communication is specified in the form of required protocol extensions and needed mechanisms that allows the increase of a single \gls{alto} server's knowledge space.

\section{General Architecture}

    Figure \ref{fig:architecture-network} presents a high-level conceptual model of how the network information flows in a given \gls{isp}.
    Network data originates in the topology itself, and is gathered into a network information aggregator by the appropriate means - this aggregator defines an interface through which network data can be uploaded, and entities utilize it to provide the network data they have collected.
    These entities will use different means to gather information, as the Internet is supported by a massive variety of protocols and standards for network and resource information querying.
    For example, a node could deploy a daemon listening for \gls{ospf} protocol packets to gather path cost information, and another using \gls{snmp} to gather node property information.
    Obviously, since the interface simply defines how raw data must be formated to be accepted by the network information aggregator, means through which the data is uploaded are left to the source itself, and because of this static data uploads that were previously collected could be used instead of dynamic retrievals - for example, the network administrator could use previously collected information that resides in a database and upload it as is.
    The network information aggregator serves as a hub for network administrators to process the raw network data that was collected by the previous tier, and transform it into \gls{alto} resources ready to be accepted and distributed by the corresponding server.
    This task of network information processing is where \gls{isp} policies and preferences are injected via, for example, the abstraction of network entities with the aggregation of network addresses into \glspl{pid}, and the creation of cost maps which result from the transformation of network link information mixed with given \gls{isp} goals.
    If, say, the administrator wished to provide a cost map between network entities which aimed to reduce inter-network traffic, it would firstly aggregate endpoints into abstract entities with common properties, as an attempt not to share too much infrastructural information, and then use the previously collected network link information, attribute higher costs to undesired links, and transform it utilizing the Dijkstra's algorithm to create a shortest path map that is bound to provider preferences.
    Such map is then parsed as an \gls{alto} resource - more specifically, a cost map - and afterwards uploaded into the \gls{alto} server with the access policies the administrator sees fit.

\begin{table}[H]
\centering
\caption{Network node entities in the conceptual ALTO system representation}
\begin{tabular}{ | c | l |}
\hline
\textbf{Image} & \textbf{Description} \\ \hline
\raisebox{-.30\height}{\includegraphics[width=8mm]{img/circle-white}} & Network node \\ \hline
\raisebox{-.30\height}{\includegraphics[width=8mm]{img/circle-blue}} & Network node participating in a given overlay network \\
\hline
\end{tabular}
\end{table}

\todo{intelligence to information}

\begin{figure}[H]
        \centering
        \hspace*{0.35cm}
        \includegraphics[scale=0.75]{img/architecture-network.png}
        \caption{Conceptual representation of the ALTO system of a given ISP}
        \label{fig:architecture-network}
\end{figure}

    More formally, Figure \ref{fig:macro-architecture} presents the proposed system architecture.
    One can identify the \gls{alto} interface - logically separated in its download and upload components - as a key factor of the system, as it allows to bridge three different application layers - the \gls{alto} resource consumer, the \gls{alto} resource provider, and the network information aggregator, to be further specified in the following sections.

    The \gls{alto} working group has extensively specified the \gls{alto} protocol, which regards to resource querying, and the concrete implementation of this work will aim to comply to it.
    However, no resource provisioning protocol was, at time of writing, specified by the working group, nor was an interface been specified to allow network data to reach the \gls{alto} server.
    It has been set as a work in progress, and the topic of network information sources was briefly discussed in \cite{alto-deployment-considerations}.
    The working group has grouped the tasks of raw network processing and supply into the role of the \gls{alto} server.
    However, as can be seen in the proposed architecture, a different approach was taken in this work, with the roles being separated and an additional protocol proposed to bridge communication between them.
    This was made as an attempt to adhere to the philosophy of single responsibility, making the sole task of the \gls{alto} server the management of \gls{alto} resources.
    This aims to facilitate the independent development of the different roles, and make it easier to interchange implementations - this would make it particularly useful, for example, to deploy many \gls{alto} servers in a cascade fashion whilst utilizing only a single network information aggregator.
    These are, however, only conceptually separated, and an implementation could, if it is more practical, merge the server and information provider roles into a single physical entity - which would then be similar to the architecture designed by the \gls{alto} working group.

    As most software architectures, each new communication channel represents a possible source of attack vectors and, attending to the critical security concerns posed in Section \ref{ssec:alto-security}, all of these channels must be secure and reliable, as signified by the padlocks on the presented architecture.
    This implies that data communications within it must be block being read or altered by non authorized users, and the identity of the participating parties can be trusted and made accountable.
    The identified communication channels must then have methods of maintaining data integrity in transit, user authentication and authorization, and communication confidentiality.

\todo{add "network data preprocessing" in network information aggregator rectangle}
\todo{replace intelligence with status}

\begin{figure}[H]
        \centering
        \includegraphics[scale=0.25]{architecture-macro2.png}
        \caption{System architecture at a macro level}
        \label{fig:macro-architecture}
\end{figure}

\section{Role system}
\label{sec:system-roles}

    As an access control measurement, the system will work with \gls{rbac} methods which, as the name states, center their control policy logic around roles, which themselves are tags that can be attributed to users.
    A pre-requisite is then that users attempting to access a system employing \gls{rbac} must be authenticated as a given user, and from then a list of attributed roles can be retrieved to validate if a given action is permitted according to the set rules.
    The \gls{alto} resources - the main interest of this system as it is the data component requested by clients and managed by the servers - has associated to it an \gls{acl}, that maps, for a given set of roles, the list of user actions that are allowed to be performed to that resource, with the implicit rule that a resource's owner has full clearance.
    The available user actions are "read", "update" and "delete", meaning the ability to get, change the contents of, or remove the resource, respectively.
    This \gls{acl} must be provided by the Network Information Aggregator whenever a new resource is inserted into the \gls{alto} server.
    The \gls{isp} administrator that controls the aggregator not only then designs the resource itself - adding the information that it deems important whilst not too detailed to damage privacy - but also defining access control policies on that resource, which will be then enforced by the server in future requests.

    Employing access control based on roles seems appropriate for this system since roles can be applied to - and thus group - many users, and indeed that seems to be applicable on real case deployments of the \gls{alto} system - each given application, that consists of a great number of users, can correspond to a single group, and more private scenarios, such as a data center server cluster, can also be grouped.
    This facilitates permission management, as the \gls{rbac} approach allows grouping of permissions into roles, which can then be quickly manipulated to affect every user associated to it - this would contrast to an approach where permissions are set per user, which would be considerably harder to manage at scale.
    As a user can be granted many roles, he can naturally act on the system with a role that fits the currently queried resource, if so applies, and likewise the network administrator can give permissions per role, which in turn can group as many as millions of users, or to just a single one.

    An \gls{rbac}-based access control mechanism will help mitigate security threats pertaining to the \gls{alto} working group's architecture - e.g. having unwanted users reading or tampering with data.
    However, for such mechanisms to be viable at all, authentication systems need to also be employed to help verify that the users are indeed who they are announcing to be.
    Authentication mechanisms are, regardless, of extreme importance, as they additionally help mitigate spoofing security threats.
    Data breaches are not, however, totally mitigated with authenticity and access control mechanisms.
    After an entity gets a resource and acts outside the system, it becomes out of its control and these mechanisms cannot be employed.
    This means that there are no guarantees that the resources are shared outside of the system's domain and consequentially there are no security guarantees after that point.
    Because of this, privilege attribution by the \gls{isp} administrators not only give clearance to do a certain action, but also imply that trust exists that these users will not be improper with the given resources, such as sharing it with users with improper clearance.

    Figure \ref{fig:communication-roles} provides a high-level communication diagram of how access control is enforced - the \gls{isp} administrator that uploads the resource into the \gls{alto} server appends to it an \gls{acl} that maps actions to the considered roles, with the implied meaning that those that weren't considered have no permitted actions.
    When a resource consumer requests an action - which is expected to be a "read" one - and proper authentication was performed to verify its identity, the server checks that the roles associated with that consumer have the requested action allowed in the \gls{acl} and, if indeed that is the case, the action performs as expected.

\begin{figure}[H]
        \centering
        \includegraphics[scale=0.55]{communication-roles.png}
        \caption{High-level communication diagram of a successful resource action request}
        \label{fig:communication-roles}
\end{figure}

\section{Resources}
\label{sec:alto-resources}

    \gls{alto} resources are pieces of network information which are provided by an \gls{alto} server and consumed by \gls{alto} clients that ideally would use such information to aid their application-level traffic decisions.
    All \gls{alto} resources can be separated into the following components:

\begin{itemize}
        \item \textbf{Meta information}: Data which regards to the resource's profile, that enable the client's ability to interpret and cross-reference the network data within.
            Meta information contains the resource's name, and if applicable, version, resource dependencies and cost details: enclosed cost modes, metrics, and descriptions.
            Finally, also belonging to the meta section of the resource's information is the resource's \gls{acl} which, to a given set of roles, specifies the allowed set of actions.

        \item \textbf{Network status information}: Data structures that give a characterization of the \gls{alto} Server's vision of a network.
            Concretely, these can map network properties to a node - such as the connection types of their interfaces, or their geographical location - they can aggregate many network addresses to a single identifier, or they can map properties to a node link or end-to-end path - such as link or cumulative routing costs.
\end{itemize}

    Meta information can be seen as a resource's header, containing data that regards to the network status and helps better handle it.
    Following the defined protocol \cite{alto-protocol}, this field includes the resource's name for all resources, which is needed for identification and indexing, and all other fields are dependant on the type of resource: at this version of the protocol, only network maps are version-able, allowing \glspl{isp} to reference different versions of a network map as they are updated, maintaining support for previously referenced versions; cost information is, naturally, only applicable to cost maps, and gives insight on how the numeric costs are to be interpreted, i.e. what their mode and metrics are, and what description it has.
    Finally, extending to the protocol is the addition of an \gls{acl} as a solution to access control needs.
    An \gls{acl} is defined as a matrix, with each entry defining a user role and actions - discussed in Section \ref{sec:system-roles} - as a restriction on what a given user was given clearance to do.

    The network status information of a network map groups endpoint addresses into a single \gls{pid} as a text literal.
    Akin to the working group's protocol, accepted endpoint address protocols include \gls{ipv4} and \gls{ipv6}, utilizing a 32 bit long bitmask to identify a subnetwork.
    Similarly, support for aggregation of \gls{mac} addresses was added, with a 48 bit long bitmask to identify address ranges, similar to the \gls{ip} variant.
    Additionally, generic overlay IDs can be added with the key "priv:X" - with "priv" meaning private scheme - where "X" is the qualified name - this naming scheme was adapted from the endpoint property map's specification done by the \gls{alto} working group, for semantic consistency.
    As endpoint addresses utilizing this scheme aren't restricted to any type, the their interpretation is also left to the client - for example, if a server defines that an endpoint addresses with "priv:my-overlay" can use regular expression to specify address ranges, a pre-agreement must exist with a client.
    Of course, if a given addressing scheme besides the previously mentioned ones becomes of relevant wide appeal, it could afterwards become part of the specification, but the existence of a private addressing scheme with liberal type and semantic verification gives liberties outside of the protocol for network status supply schemes that aren't supported officially.
    A valid network map must unambiguously map every address in the domain range to a single \gls{pid}, and whenever multiple matches occur, wins the longest prefix match.
    As the custom addressing schemes let the network map be interpreted in an undefined way by the protocol, the server cannot properly assert to the matching validity, and thus default protocol addressing schemes for network maps should be preferred, as semantic validity in private addressing schemes is not checked.
    Table \ref{table:networkmap-example} provides an example network status component of a network map within the topology in Figure \ref{fig:example-topology-boundary}.
    Three \glspl{pid} are given, each taking portion of an \gls{ipv4}, \gls{ipv6}, \gls{mac}, and custom overlay address range.
    The private address scheme groups users in regards to their private overlay ID, and it can be seen that nodes with ID 1, 3, and 4 are grouped to a single \gls{pid}, which can be seen to belong inside the \gls{isp} domain.
    Lastly, nodes 2 and 5 are given different \glspl{pid} as they reside outside the \glspl{is} domain but are reachable through different peering points.
    The \gls{isp} could then in this case leverage the network map to logically group collections of endpoints by reachability - those local to their domain, and those reachable by one of the two possible peering points, which could be subjected to different peering agreements and as such should be treated differently in resources that reference this network map.

\todo{add ipv4 and mac addresses to nodes}

\begin{figure}[H]
        \centering
        \includegraphics[scale=1.00]{img/topology-boundary.png}
        \caption{Example network topology with ISP boundary}
        \label{fig:example-topology-boundary}
\end{figure}


\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|c|}
    \hline
PID  & IPv4          & IPv6                  & MAC                  & priv:my-overlay                     \\ \hline
1    & 10.20.3.0/24  & -                     & D0-9F-BF-2A-00-00/32 & [1, 3, 4]                           \\ \hline
2    & 10.20.3.10/25 & -                     & D0-9F-BF-2A-FE-00/40 & 2                                   \\ \hline
3    & 0.0.0.0/0     & ::/0                  & 00-00-00-00-00-00/48 & 5                                   \\ \hline
\end{tabular}
\caption{Example network map referencing Figure \ref{fig:example-topology-boundary}}
\label{table:networkmap-example}
\end{table}

    A cost map contains a list of cost map matrices, with each matrix setting pairwise values between an origin entity and a destination entity.
    If it is a standard cost map, these entities are represented by \glspl{pid} that can be cross-referenced from a network map which this resource depends on, whereas if it is an endpoint cost map, these entities are endpoint addresses which, similar to network maps, include \gls{ipv4}, \gls{ipv6}, \gls{mac} and private endpoint types.
    A matrix must specify the type of cost represented with both their cost type and cost mode, with available options being the ones specified in the ongoing \gls{alto} group's cost metric specification \cite{alto-cost-metrics}.
    Optionally, a cost matrix can specify calendar information about that matrix - similar to the current work in \cite{alto-calendar-cost-map} - which signifies that besides having single-value costs - which are obligatory for any cost matrix - it also contains a time-sensitive list of costs that must be interpreted according to the calendar information provided, and give a chronological overview of what the costs will be in the future.
    If the \gls{isp} contains full topological knowledge of the resource it is sharing, the information that can be provided by the cost maps can be quite detailed.
    Consider the topology in Figure \ref{fig:example-topology} with its five network nodes - from the cost map presented in Figure \ref{table:costmap-example-non-boundary}, one cost matrix depicts a generic "routingcost" cost matrix, depicting routing preference as a shortest path map with a Dijkstra algorithm and hop count as its link cost, and another could provide a "delay-ow" cost matrix, depicting expected one-way delay in milliseconds, as the cumulative calculation of known link delays.

\begin{figure}[H]
        \centering
        \includegraphics[scale=1.00]{img/topology.png}
        \caption{Example overlay network topology without ISP boundary}
        \label{fig:example-topology}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subtable}{.4\linewidth}
        \centering
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode   & \multicolumn{5}{|l|}{routingcost} \\ \hline
        Cost Metric & \multicolumn{5}{|l|}{numerical}   \\ \hline
        From/To     & 1    & 2     & 3   & 4   & 5      \\ \hline
        1           & 0    & 1     & 1   & 2   & 3      \\ \hline
        2           & 1    & 0     & 2   & 3   & 4      \\ \hline
        3           & 1    & 2     & 0   & 1   & 2      \\ \hline
        4           & 2    & 3     & 1   & 0   & 1      \\ \hline
        5           & 3    & 4     & 2   & 1   & 0      \\ \hline
        \end{tabular}
    \caption{Routing cost cost matrix}
    \end{subtable}
    \begin{subtable}{.4\linewidth}
        \centering
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode   & \multicolumn{5}{|l|}{delay-ow}    \\ \hline
        Cost Metric & \multicolumn{5}{|l|}{numerical}   \\ \hline
        From/To     & 1    & 2     & 3   & 4   & 5      \\ \hline
        1           & 0    & 2     & 2   & 5   & 6      \\ \hline
        2           & 2    & 0     & 4   & 7   & 8      \\ \hline
        3           & 2    & 4     & 0   & 3   & 4      \\ \hline
        4           & 5    & 7     & 3   & 0   & 1      \\ \hline
        5           & 6    & 8     & 4   & 1   & 0      \\ \hline
        \end{tabular}
    \caption{One way packet delay cost matrix}
    \end{subtable}

    \caption{Example cost map for overlay in Figure \ref{fig:example-topology}}
    \label{table:costmap-example-non-boundary}
\end{figure}

    Without either full administrative control or some multi-\gls{alto} domain orchestration mechanism, a single \gls{alto} server instance is restricted to the information it knows.
    Being bound by limited topological knowledge, however, does not necessarily mean that valuable inter-layer cooperation is not possible, and will now be subject of discussion.
    The network map presented previously contains in of itself important information, grouping endpoints into \glspl{pid} that represent network borders - one local to the server, and two representing the peering relationships.
    This is relevant to help clients localize their traffic and would be impossible to derive without \glspl{is} insight.
    Table \ref{table:costmap-example-boundary} provides an example of cost matrices within a single cost map that consider a limited single \gls{alto} server domain topology in Figure \ref{fig:example-topology-boundary}.
    Notice how the \glspl{is} administrative domain is within scope of only three of the five network nodes.
    The \gls{isp} only possesses detailed network status information that regards to nodes "1", "3" and "4", which limits the amount of topological information that can be retrieved and shared to \gls{alto} clients - however, it's still very much possible to dictate routing preferences and gaps in knowledge can be filled with probing measurements to be collected and centralized by the \gls{alto} server to acquire historical performance metrics.
    As can be seen, a generic "routingcost" cost matrix is presented, whose value increases with the associated costs of transferring data through that path, and constructed as the \gls{isp} best sees fit - costs within the \gls{isp} domain are minimal, whereas paths that originate locally and target "PID2" or "PID5" - both requiring the utilization of peering links - are less preferable, with the former being at least twice more preferable than the latter.
    A "delay-ow" cost matrix is also provided, specifying one way packet delay in milliseconds, with the \gls{isp} applying preceding probing measurements between endpoints and averaging the results.
    Finally, a "tput" cost matrix can be seen, specifying expected throughput in bytes per second, with the \gls{isp} applying probing measurements, topological insight, as well as collected feedback of previous application connections that occurred between endpoints to deduce available bandwidth between target points in practice.
    Additionally, the inclusion of cost calendar capabilities to the cost matrix enables users to get a chronological view of bandwidth availability at rush hours, with the single value cost being updated to the present time if a decision needs to be made only considering the current time.
    A similar cost matrix is presented next, that, instead of specifying the throughput costs as dimensional values, does so instead in an ordinal fashion, where the number represents a ranking position in preference, with a lower number representing higher preference.
    This is an alternative that preserves ranking information without requiring from the \gls{isps} the need to concretely specify network status, and instead ordering connections by relative preference, with the option of assigning equal preference to paths that differ in a given order of magnitude that the \gls{isp} sees as negligible.
    In the presented case, locality is correlated with more reliable communications and less operational costs from the \gls{isp}'s point of view, and a concrete better choice exists - regarding routing cost, delay, and throughput - between the two peering connections
    That information can be part of the \gls{alto} system as query-eligible by client applications that can now better optimize their network-related decisions in a mutually beneficial scenario.

\begin{figure}
    \centering
    \begin{subtable}{.46\linewidth}
        \centering
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode   & \multicolumn{5}{|l|}{routingcost} \\ \hline
        Cost Metric & \multicolumn{5}{|l|}{numerical}   \\ \hline
        From/To     & 1    & 2     & 3   & 4   & 5      \\ \hline
        1           & 0    & 10    & 1   & 2   & 22     \\ \hline
        2           & -    & -     & -   & -   & -      \\ \hline
        3           & 1    & 11    & 0   & 1   & 21     \\ \hline
        4           & 2    & 22    & 1   & 0   & 20     \\ \hline
        5           & -    & -     & -   & -   & -      \\ \hline
        \end{tabular}
    \caption{Routing cost cost matrix}
    \end{subtable}
    \begin{subtable}{.46\linewidth}
        \centering
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode   & \multicolumn{5}{|l|}{delay-ow}    \\ \hline
        Cost Metric & \multicolumn{5}{|l|}{numerical}   \\ \hline
        From/To     & 1    & 2     & 3   & 4   & 5      \\ \hline
        1           & 2    & 20    & 1.5 & 3   & 42     \\ \hline
        2           & -    & -     & -   & -   & -      \\ \hline
        3           & 4    & 24    & 2   & 2   & 39     \\ \hline
        4           & 7    & 27    & 2   & 2   & 36     \\ \hline
        5           & -    & -     & -   & -   & -      \\ \hline
        \end{tabular}
    \caption{One way packet delay cost matrix}
    \end{subtable}
    \begin{subtable}{.65\linewidth}
        \centering
        \hspace{-4em}
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode   & \multicolumn{5}{|l|}{tput}                       \\ \hline
        Cost Metric & \multicolumn{5}{|l|}{numerical}                  \\ \hline
        From/To     & 1         & 2     & 3        & 4        & 5      \\ \hline
        1           & 256000    & 10000 & 256000   & 256000   & 5000   \\ \hline
        2           & -         & -     & -        & -        & -      \\ \hline
        3           & 256000    & 10000 & 256000   & 256000   & 5000   \\ \hline
        4           & 256000    & 10000 & 256000   & 256000   & 5000   \\ \hline
        5           & -         & -     & -        & -        & -      \\ \hline
        \end{tabular}
    \caption{TCP throughput cost matrix}
    \end{subtable}
    \begin{subtable}{.30\linewidth}
        \centering
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode   & \multicolumn{5}{|l|}{tput}                       \\ \hline
        Cost Metric & \multicolumn{5}{|l|}{ordinal}                    \\ \hline
        From/To     & 1         & 2     & 3        & 4        & 5      \\ \hline
        1           & 1         & 2     & 1        & 1        & 3      \\ \hline
        2           & -         & -     & -        & -        & -      \\ \hline
        3           & 1         & 2     & 1        & 1        & 3      \\ \hline
        4           & 1         & 2     & 1        & 1        & 3      \\ \hline
        5           & -         & -     & -        & -        & -      \\ \hline
        \end{tabular}
    \caption{TCP throughput ranking cost matrix}
    \end{subtable}
    \begin{subtable}{1\linewidth}
        \footnotesize
        \centering
        \hspace*{-2em}
        \begin{tabular}{|l|l|l|l|l|l|}
        \hline
        Cost Mode                & \multicolumn{5}{|l|}{tput}                            \\ \hline
        Cost Metric              & \multicolumn{5}{|l|}{numerical}                       \\ \hline
        Calendar Start           & \multicolumn{5}{|l|}{Tue, 20 Sep 2020 17:00:00 GMT}   \\ \hline
        Calendar Interval size   & \multicolumn{5}{|l|}{7200}                            \\ \hline
        Calendar Interval number & \multicolumn{5}{|l|}{6}                               \\ \hline
        From/To                  & 1                    & 2                     & 3                        & 4                   & 5                  \\ \hline
        1                        & (1,[1,1,1,2,2,1])    & (2,[2,2,2,1,1,2])     & (1,[1,1,1,2,2,1])        & (1,[1,1,1,2,2,1])   & (3,[3,3,3,2,2,1])  \\ \hline
        2                        & -                    & -                     & -                        & -                   & -                  \\ \hline
        3                        & (1,[1,1,1,2,2,1])    & (2,[2,2,2,1,2,1])     & (1,[1,1,1,2,1,1])        & (2,[2,2,2,1,1,1])   & (1,[3,1,1,1,1,1])  \\ \hline
        4                        & (1,[1,1,2,2,1,1])    & (1,[2,2,1,1,1,1])     & (1,[1,1,1,1,2,1])        & (2,[1,1,2,2,2,2])   & (3,[3,3,3,3,2,2])  \\ \hline
        5                        & -                    & -                     & -                        & -                   & -                  \\ \hline
        \end{tabular}
    \caption{TCP throughput cost matrix with calendar values}
    \end{subtable}

    \caption{Example cost map for the limited \gls{isp} domain in \ref{fig:example-topology}}
    \label{table:costmap-example-boundary}
\end{figure}

    \newpage

    The network status information of an endpoint property map stores the property information of a given endpoint.
    The \gls{alto} working group's protocol specification \cite{alto-protocol} does not directly specify what kind of properties are pondered for this map.
    Following the same design pattern used for the other specified resources, the endpoint property map will have a set of defined properties with associated semantics, and all other properties can be added with the "priv" prefix to designate private properties outside of the considered domain, and thus all semantics and validation rules don't apply.
    Much like the other resources, an endpoint can be identified by an \gls{ipv4}, \gls{ipv6}, \gls{mac} or private overlay address, and the pondered properties are \gls{pid} value, geographical coordinates, connection type (fiber, \gls{adsl}, etc.), server footprint information (total \gls{ram}, \gls{cpu}, and storage), and server status information (what portion of the footprint information is currently available, such as free processing power).
    In practice, a given property could be promoted from a private type to one pondered in the protocol and have a resulting official semantic and validation rules.
    Table \ref{table:example-endpoint-prop} display an example endpoint property map, which is used to store status information relating to servers, identified by their \gls{ipv4} address, that serve the same content.

    \begin{table}[H]
    \centering
    \hspace*{-3.8em}
    \begin{tabular}{|l|l|l|l|l|l|}
    \hline
    Endpoint        & CPU \% & RAM \% & Geographic Coordinates & Connection type & priv:is-mirror \\ \hline
    145.132.164.101 & 22     & 50     & (34.28278,-82.50490)   & Fiber           & False          \\ \hline
    245.217.176.67  & 30     & 45     & (23.24178,-53.51290)   & Fiber           & True           \\ \hline
    48.43.96.168    & 25     & 30     & (55.33218,-12.50490)   & Fiber           & True           \\ \hline
    207.20.148.21   & 10     & 20     & (-23.28121,-22.55530)  & Fiber           & True           \\ \hline
    89.140.253.77   & 5      & 0      & (12.231278,75.70890)   & Fiber           & True           \\ \hline
    \end{tabular}
    \caption{Example endpoint property map for server replicas}
    \label{table:example-endpoint-prop}
    \end{table}

    Finally, as a means to facilitate resource divulgence from servers to clients, there is also included the specification of an \gls{ird}, that is also based from the \gls{alto} working group's protocol specification \cite{alto-protocol}.
    An \gls{ird} can also be thought of as a resource, but instead of sharing network information, it serves as an index of the available resources that a given server provides.
    Each server must have available for query a single \gls{ird}, that lists all the available resources it provides, along with their metadata.
    Each resource attribute must contain the resource's ID, its \gls{http} media type and, if applicable, their capabilities, accepted input media types, and resource dependencies.
    The capabilities identifies, if existing, the cost and property types that are used - being indexed by their unique name, this allows for these to be cross-referenced on further protocol exchanges without need to repeat information.
    Additionally, the resource's capabilities also serve to indicate what resource functionality extensions are enabled - currently applicable for cost maps only, it serves to signal if the cost map has calendared costs - a protocol extension adapted from the work in progress in \cite{alto-calendar-cost-map}, that serves to retrieve calendar cost values, or if the multi-cost extension functionality exists - a protocol extension adapted from \cite{alto-multi-cost}, which lets multiple matrices be requested at once to save on overhead traffic that would otherwise be necessary to request many matrices.
    Two additions are made to the working group's specification - firstly, a description field, which for each resource attribute gives a brief description of what it is about, as it could facilitate resource selection, since such a description could go into detail about appropriate usage guidelines of that resource and suggested use cases; finally, the resource's \gls{acl}, letting a user know beforehand what clearances the given resource has - being a crucial part of the metadata, it seems fitting to go into the \gls{ird}, and has the added benefit of giving the user this piece of information without him having to make resource requests just to, by server reaction, figure out what he can and cannot do.
    A default network map entry must also exist in the \gls{ird}, as per the working group's specification, to serve as a guideline for clients that wish to use the most basic of \gls{isp} endpoint groupings.

    An example \gls{ird} is provided in \ref{table:ird-example}.
    A list of available costs and properties is presented, with their descriptive data discussed above, along with the available resources provided by that server, which contains data useful for their server cluster, as well as a broader-purpose endpoint cost map to query for path connection types and facilitate user selection.
    Finally, a default network map is presented.

\begin{figure}[H]
    \centering
        \begin{subtable}{1\linewidth}
        \centering
        \begin{tabular}{|l|l|l|L|}
        \hline
        \bf{Cost ID}     & \bf{Cost Mode}   & \bf{Cost Metric} & \multicolumn{1}{m{5cm}|}{\bf{Description}}                                                                \\ \hline
        routing          & routingcost      & numerical        & \multicolumn{1}{m{5cm}|}{Default routing preference}                                                      \\ \hline
        routing-rank     & routingcost      & ordinal          & \multicolumn{1}{m{5cm}|}{Routing preference by ranking}                                                   \\ \hline
        owd              & delay-ow         & numerical        & \multicolumn{1}{m{5cm}|}{Expected one way delay of a single packet. Based on application statistics}      \\ \hline
        tput-theoretical & tput             & numerical        & \multicolumn{1}{m{5cm}|}{Theoretical maximum available TCP throughput. Based on topological knowledge}    \\ \hline
        tput-practical   & tput             & numerical        & \multicolumn{1}{m{5cm}|}{Practical expected TCP throughput. Based on application statistics}              \\ \hline
        \end{tabular}
        \caption{Available cost types}
        \end{subtable}

        \begin{subtable}{1\linewidth}
        \centering
        \begin{tabular}{|l|l|l|}
        \hline
        \bf{Property ID} & \bf{Property type}         & \bf{Description}                              \\ \hline
        cpu              & CPU                        & Machine's current CPU load                    \\ \hline
        ram              & RAM                        & Machine's currently occupied RAM                \\ \hline
        coord            & geographic-coordinate      & Machine's geographical coordinates            \\ \hline
        connection       & connection-type            & Machine interface's connection type           \\ \hline
        is-mirror        & priv:is-mirror             & Flag stating if machine is a mirror of original server\\ \hline
        \end{tabular}
        \caption{Available property types}
        \end{subtable}

        \begin{subtable}{1\linewidth}
        \centering
        \hspace*{-8em}
        \tiny
        \begin{tabular}{|l|l|l|l|l|l|l|}
        \hline
        Resource ID             & URI                                & Media Type        & Uses           & Accepts                 & Capabilities                                              & Description                                   \\ \hline
        def-nmap          & resources/networkmaps/default      & alto-networkmap   & -              & alto-networkmapfilter   & -                                                         & Default                           \\ \hline
        cluster-costmap         & resources/costmaps/cluster         & alto-costmap      & def-networkmap & alto-costmapfilter      & Costs: {[}routing, routing-rank{]} & For main data center cluster         \\ \hline
        cluster-endprop   & resources/endpointpropmaps/cluster & alto-endpointprop & -              & alto-endpointpropparams & Properties: {[}cpu, ram, coords{]} & For main data center cluster \\ \hline
        client-endcost & resources/endpointcostmaps/        & alto-endpointcost & -              & alto-endpointcostparams & Costs: {[}routing-rank, owd, tput-practical{]}            & For user application guidance       \\ \hline
        \end{tabular}
        \caption{Available resources}
        \end{subtable}
        \begin{subtable}{1\linewidth}
        \centering
        \begin{tabular}{|l|l|l|L|}
        \hline
        \bf{Resource ID} \\ \hline
        def-nmap         \\ \hline
        \end{tabular}
        \caption{Default Network Map}
        \end{subtable}

    \caption{Example of an \gls{ALTO} server's \gls{ird}}
    \label{table:ird-example}
\end{figure}

Further formal specification is not made as it has been extensively done in the \gls{alto} protocol \cite{alto-protocol}, and the proposed system complies to it whilst extending upon the design.

\section{Roles}

\subsection{ALTO Client}

    An \gls{alto} resource consumer is materialized in the architecture in the form of an \gls{alto} client, which can be any entity who is able to interface with an \gls{alto} server to query for \gls{alto} resources.
    Whilst the \gls{alto} working group was initially devised to help increase \gls{p2p}-related traffic localization via the sharing of network information, it now has an increased scope where an ideal client is any application which generates network traffic and would be able to optimize it with aid from an oracle entity with privileged network information.
    Thus, an \gls{alto} client is fit to be implemented in \gls{p2p} applications, and could be embedded in a \gls{p2p} client itself to help with picking neighbouring and content providing nodes, or on a tracker that would accomplish the same goal on behalf of the querying peer.
    Likewise, nodes which are unable to optimally select between other nodes, such as \gls{cdn} edge nodes or content mirrors, could also benefit from oracle guidance, and thus qualify as appropriate \gls{alto} clients.

    Figure \ref{fig:communication-p2p} exemplifies how a cooperative \gls{p2p} application would, acting as an ALTO client, interact with the ALTO server to retrieve relevant network resources to aid their application choice of what candidate peer to consume a service from.
    Firstly, a network map is retrieved to help group endpoints into groupings, and afterwards a cost map is retrieved filtering only the querying peer as source, candidate peers as destinations, and the routing cost and bandwidth cost matrices.
    Acting on this information, the peer chooses the candidate that gives a good balance between \gls{isp} routing cost and path bandwidth, making a decision that should ideally benefit both them and the \gls{isp} that helped provide that information.

\todo{create communication p2p example diagram}

\begin{figure}[H]
        \centering
        \includegraphics[scale=0.35]{communication-p2p.png}
        \caption{High-level communication diagram of a \gls{p2p} application utilizing \gls{ALTO}}
        \label{fig:communication-p2p}
\end{figure}

    Figure \ref{fig:communication-tracker} is similar to the previous example, in the sense that it aids a \gls{p2p} application by resorting to \gls{alto}'s guidance, but this time the application-level traffic optimization is made in a way that is transparent to the \gls{p2p} client.
    As a choice to purely localize traffic - as this alone can bring plenty of benefits to both layers - and as a means to minimize protocol modification, it is the tracker that acts as an \gls{alto} client.
    Whenever a request is made by a \gls{p2p} client to retrieve peers serving a given data chunk, the tracker first consults with the \gls{alto} server and retrieves its network map that groups peers within administrative domains - either inside the providing \gls{isp}'s domain, thus the local network, and outside administrative domains, grouped by types of peering connections to different autonomous regions.
    The tracker could use a very simple algorithm to filter out of its candidate pool peers that reside outside of the \gls{isp} region where the requesting \gls{p2p} client resides, if a local alternative exists.
    After packaging a reply to the \gls{p2p} client, the protocol acts normally and traffic could be successfully localized with minimal impact.

\begin{figure}[H]
        \centering
        \hspace*{-1em}
        \includegraphics[scale=0.40]{communication-tracker.png}
        \caption{High-level communication diagram of a tracker utilizing \gls{ALTO} by proxy}
        \label{fig:communication-tracker}
\end{figure}

    On the same vein, Figure \ref{fig:cdn-communication} exemplifies how this time a \gls{cdn} controller would use the system to better help its decision in matching \gls{cdn} clients to an edge server on their system.
    To do this, it retrieves a property map to query for server status information, and subsequently retrieves a cost map to query for path information between the \gls{cdn} client and the candidate edge servers.
    Having all the relevant server status information, e.g. available processing and storage resources, as well as connection properties, e.g. max possible bandwidth, latency, and packet loss, the \gls{cdn} controller is in a condition to more optimally redirect his client.

\begin{figure}[H]
        \centering
        \hspace*{-2em}
        \includegraphics[scale=0.40]{communication-cdn.png}
        \caption{High-level communication diagram of a \gls{cdn} controller utilizing \gls{alto}}
        \label{fig:communication-cdn}
\end{figure}

\subsection{ALTO Server}

    An \gls{alto} resource provider is the \gls{alto} server, an entity that possesses pre-processed and authorized network information in the form of \gls{alto} resources.
    Its job is to store and manage such resources so they can be provided to querying \gls{alto} clients, with the additional responsibilities of data validation and persistence.
    Conceptually, the \gls{alto} server is seen as a single entity, but considering the sensible information that could be stored within it and the influence it has on shaping network traffic, it would not be uncommon for an \gls{alto} server to have a knowledge domain correspondent to the \gls{isp} that owns it.
    Physically, though, the resource provider layer could consist of many interlinked \gls{alto} providers with an increased coverage area of network knowledge.
    Means through which this could occur are further specified in Section \ref{ssec:multi-alto}.

    A listing of available \gls{http} endpoints of the \gls{alto} server interface is available in Table \ref{table:alto-server-api}.
    All resource types hierarchically descend from a "resources" path, and each unique type of resource exposes his own endpoint, with the methods to add, update, remove, and retrieve with and without filter as arguments.
    These methods are subjected to the access control mechanisms discussed in Section \ref{sec:system-roles}, as one should only expect reputable sources to upload and modify data, and only permitted users to query it.

\begin{table}[]
\resizebox{\textwidth}{!}{\begin{tabular}{|l|l|l|}
    \hline
HTTP Verb & Resource                           & Description                                                                                   \\ \hline
GET       & /resources                         & Retrieve the Information Resource Directory for that server                                   \\ \hline
GET       & /resources/networkmaps             & Get summary overview of all available network maps                                            \\ \hline
POST      & /resources/networkmaps/            & Add a new Network Map                                                                         \\ \hline
GET       & /resources/networkmaps/\{id\}      & Get the Network Map with the specified ID                                                     \\ \hline
POST      & /resources/networkmaps/\{id\}      & Get the Network Map with the specified ID, with the applied filter provided in body           \\ \hline
PUT       & /resources/networkmaps/\{id\}      & Modify the contents of a Network Map with the specified ID                                    \\ \hline
DELETE    & /resources/networkmaps/\{id\}      & Remove a Network Map with the specified ID                                                    \\ \hline
GET       & /resources/costmaps                & Get summary overview of all available cost maps                                               \\ \hline
POST      & /resources/costmaps                & Add a new Cost map                                                                            \\ \hline
GET       & /resources/costmaps/\{id\}         & Get the Cost Map with the specified ID                                                        \\ \hline
POST      & /resources/costmaps/\{id\}         & Get the Cost Map with the specified ID, with the applied filter provided in body              \\ \hline
PUT       & /resources/costmaps/\{id\}         & Modify the contents of a Cost Map with the specified ID                                       \\ \hline
DELETE    & /resources/costmaps/\{id\}         & Remove a Cost Map with the specified ID                                                       \\ \hline
GET       & /resources/endpointpropmaps        & Get summary overview of all available Endpoint Property Maps                                  \\ \hline
POST      & /resources/endpointpropmaps        & Add a new Endpoint Property map                                                               \\ \hline
GET       & /resources/endpointpropmaps/\{id\} & Get the Endpoint Property Map with the specified ID                                           \\ \hline
POST      & /resources/endpointpropmaps/\{id\} & Get the Endpoint Property Map with the specified ID, with the applied filter provided in body \\ \hline
PUT       & /resources/endpointpropmaps/\{id\} & Modify the contents of an Endpoint Property Map with the specified ID                         \\ \hline
DELETE    & /resources/endpointpropmaps/\{id\} & Remove an Endpoint Property Map with the specified ID                                         \\ \hline
GET       & /resources/endpointcostmaps        & Get summary overview of all available Endpoint Cost Maps                                      \\ \hline
POST      & /resources/endpointcostmaps        & Add a new Endpoint Cost Map                                                                   \\ \hline
GET       & /resources/endpointcostmaps/\{id\} & Get the Endpoint Cost Map with the specified ID                                               \\ \hline
POST      & /resources/endpointcostmaps/\{id\} & Get the Endpoint Cost Map with the specified ID, with the applied filter provided in body     \\ \hline
PUT       & /resources/endpointcostmaps/\{id\} & Modify the contents of an Endpoint Cost Map with the specified ID                             \\ \hline
DELETE    & /resources/endpointcostmaps/\{id\} & Remove an Endpoint Cost Map with the specified ID                                             \\ \hline
\end{tabular}}
\caption{\gls{alto} server's available endpoints}
\label{table:alto-server-api}
\end{table}


\subsubsection{Resource Filtering}

    Resource filtering is the task through which a resource consumer can pass a filter object to the resource provider that specifies the parameters that the consumer wishes to retrieve specifically.
    With it, there's no need to pass more information to the client than he wishes to get, thus minimizing used network bandwidth and client \gls{cpu} cycles to send and process the resource, respectively.
    The need for filtering becomes greater at a larger system scale - with an increased number of users that query routinely, and resources that can have a massive amount of entries - specifically those that regard to network endpoints - such a mechanism becomes a necessary optimization.
    Keeping with the objective of implementing a fully compatible \gls{alto} protocol as specified by the working group, so will the resource filtering specifications be equal to those already specified in the protocol design \cite{alto-protocol}, thus no further specification will be necessary.

    For clarification, the \gls{alto} server must maintain an endpoint for retrieving all main specified network status resources via filtering, i.e. the server must let the client retrieve \gls{alto} resources with parametrization that dictates what concrete fields must be delivered.
    The types of resource filters considered are the following:

    \begin{itemize}
        \item \textbf{Network Map filter}: List of \gls{pids} of value $PID\_List$, that if empty signifies the entire subset of available \gls{pids}.
            All entries of value:

            \begin{center}
            $(PID, Endpoint\_List)$, $PID \in PID\_List$
            \end{center}

            must be retrieved, and all others must be filtered out.

        \item \textbf{Endpoint Property Map filter}: Pair of list of endpoints and list of properties that must be selected, of value $(Endpoint\_List, Property\_List)$.
            All entries of value

            \begin{center}
            $(Endpoint, Property)$, $Endpoint \in Endpoint\_List \land Property \in Property\_List$
            \end{center}

            must be retrieved, and all others must be filtered out.

        \item \textbf{Cost Map filter}: Tuple of list of source \gls{pids}, list of destination \gls{pids}, list of cost types and list of cost value conditionals of value

            $(SrcPID\_LIST, DstPID\_LIST, CostType\_List, CostValueConditional\_List)$,

            with $CostType\_List > 1$ assuming a multi-cost map extension and the emptiness of any of the lists signifying the entire subset of available values.
            All entries of value

            \begin{center}
            $(Src\_PID, Dst\_PID, Cost\_Type, Cost\_Value)$, $Src\_PID \in SrcPID\_List \land Dst\_PID \in DstPID\_List \land Cost\_Type \in CostType\_List \land satisfies\_atleast\_one(Cost\_Value, CostValueConditional\_List)$
            \end{center}

             must be retrieved, and all other must be filtered out.

         \item \textbf{Endpoint Cost Map filter}: Equal to the cost map filter, but considering a list of source and destination endpoint filters instead of \gls{pids}.
    \end{itemize}

    By analogy, one can consider the \gls{alto} server to act as a remote database with an interface for clients to interact with it, and the filters act as selection statements, such as the "SELECT" method in \gls{sql} databases, to retrieve specific parts of the dataset.
    The filters of cost maps and endpoint cost maps also include a list of premises which themselves are logical operators applied to the candidate cost values.
    Continuing the analogy, these allow the clients to use "WHERE" statements on the numerical cost values that are retrieved.
    In summary, the filter functionality could be explained in the examples shown in Table \ref{table:filter-examples}.

\begin{table}[H]
    \resizebox{\textwidth}{!}{\begin{tabular}{|l|l|l|L|}
    \hline
\bf{HTTP Verb} & \bf{Resource}    & \bf{Body}  & \multicolumn{1}{m{8cm}|}{\bf{Description}} \\ \hline

    POST      & resources/networkmaps/default      & \begin{tabular}[c]{@{}l@{}}\{ \\ "pids": $[$"PID1", "PID2"$]$\\ \} \end{tabular} & \multicolumn{1}{m{8cm}|}{Retrieve an network map with id "default", filtering the entries for \gls{pids} "PID1" and "PID2"} \\ \hline
    POST      & resources/endpointpropmaps/default & \begin{tabular}[c]{@{}l@{}}\{ \\ "endpoints": $[$"ipv4:10.0.0.1", "ipv4:10.0.0.2"$]$,\\  "properties": $[$"CPU", "RAM", "connection-type"$]$ \\ \}\end{tabular}  & \multicolumn{1}{m{8cm}|}{Retrieve an endpoint property map with the id "default", filtering the entries for the properties "CPU", "RAM", and "connection-type" and the \gls{ipv4} endpoints "10.0.0.1" and "10.0.0.2"} \\ \hline
    POST      & resources/costmaps/default         & \begin{tabular}[c]{@{}l@{}}\{ \\ "cost-type": \{ & \quad "cost-mode" : "numerical",\\ \quad "cost-metric": "routingcost" \\ \},\\  "pids": \{ \\ \quad "srcs" : $[$"PID1"$]$,\\ \quad "dsts": $[]$ \\ \quad \} \\ \} \end{tabular} & \multicolumn{1}{m{8cm}|}{Retrieve the cost map with the id "default", filtering the entries for the cost matrix with cost mode "numerical" and cost metric "routingcost", whose entries have source \gls{pid} "PID1" and any destination} \\ \hline
    POST      & resources/costmaps/default         & \begin{tabular}[c]{@{}l@{}}\{ \\ "multi-cost-types": \\ \quad $[$ \\ \quad \{ \\ \quad "cost-mode" : "numerical",\\ \quad "cost-metric": "routingcost" \\ \quad \},\\  \quad \{ \\ \quad "cost-mode": "ordinal",\\ \quad "cost-metric": "routingcost" \\ \quad \} \\ \quad $]$,\\ "pids" : \{ \\ \quad "srcs": $[$"PID1", "PID2"$]$,\\ \quad "dsts" : $[$"PID3"$]$ \\ \quad \} \\ \}\end{tabular} & \multicolumn{1}{m{8cm}|}{Retrieve the cost map with the id "default" and, assuming a multi-cost protocol extension, retrieve both the "numerical" and "ordinal" variations of the "routingcost" metric, whose entries have source \gls{pid} "PID1" or "PID2", and destination "PID3"} \\ \hline
     POST      & resources/costmaps/default         & \begin{tabular}[c]{@{}l@{}}\{ \\ "multi-cost-types": \\ \quad $[$ \\ \quad \{ \\ \quad "cost-mode" : "numerical",\\ \quad "cost-metric": "routingcost" \\ \quad \},\\ \quad \{ \\ \quad "cost-mode": "numerical", \\ \quad "cost-metric": "delay-ow" \\ \quad \} \\ \quad $]$,\\ "calendared": $[$false, true$]$,\\ "pids" : \{ \\ \quad "srcs": $[]$,\\ \quad "dsts" : $[$"PID3"$]$ \\ \quad \}\\ \}\end{tabular}                                                                                           & \multicolumn{1}{m{8cm}|}{Retrieve the cost map with the id "default" and, assuming a multi-cost and cost calendar protocol extensions, retrieve the numerical variants of the "routingcost" and "delay-ow" metrics, requesting a singular value and a calendar value respectively, of all entries whose destination is "PID3"} \\ \hline
     POST      & resources/costmaps/default         & \begin{tabular}[c]{@{}l@{}}\{ \\ "multi-cost-types": \\ \quad $[$ \\ \quad \{ \\ \quad "cost-mode" : "numerical", \\ \quad "cost-metric": "delay-ow" \\ \quad \}, \\ \quad \{ \\ \quad "cost-mode": "ordinal",\\ \quad "cost-metric": "routingcost" \\ \quad \} \\ \quad $]$,\\ "pids" : \{ \\ \quad "srcs" : $[$"PID1"$]$,\\ \quad "dsts" : $[$"PID2"$]$ \\ \quad \},\\ "or-constraints" : \{ \\ \quad $[$ \\ \quad $[$"$[$0$]$ ge 0","$[$0$]$ le 20"$]$,\\ \quad $[$"$[$1$]$ eq 1"$]$ \\ \quad $]$\\ \quad \} \\ \} \end{tabular} & \multicolumn{1}{m{8cm}|}{Retrieve the cost map with the id "default" and, assuming a multi-cost protocol extension, retrieve the "numerical" mode of the "ow-delay" metric and the "ordinal" mode of the "routingcost" metric, whose entires have source "PID1" and destination "PID2", and whose cost values satisfy for a given source and destination pair that either the "ow-delay" is within 0 and 20 ms or it's the number one preferencial "routingcost" value} \\ \hline
\end{tabular}}
\caption{Example \gls{alto} queries with the filtering functionality}
\label{table:filter-examples}
\end{table}


\subsubsection{Server discovery}

    \gls{alto} server discovery, by hand of either network information aggregators or resource consumers, must be done leveraging existing \gls{dns} technologies.
    Each server entity maintains a given domain name, and along it is included the need to also maintain domain records in the chosen \gls{dns} system to map the domain name to the server's \gls{ip} address.
    Much like the choice to utilize \gls{http} as an application protocol, so do the server discovery mechanisms aim to comply with the \gls{alto} working group's philosophy of leveraging existing proven technologies when possible as a means to facilitate development and minimize errors, with the added benefit of extending functionality with the chosen technologies since it is mature and has plenty of options.
    With \gls{dns}, this gives flexibility of either privately configuring domain name to \gls{ip} addresses - much like happens in Linux systems with the "/etc/hosts" file - or its deployment by leveraging existing authoritative \gls{dns} servers.
    Additionally, by working around the existing technology and its specification, one can easily implement load balancing for performance reasons, or, among others, \gls{doh} for preventing eavesdropping, and ensuring both data integrity and host authenticity \cite{dns-https}.
    A similar approach is to be taken for network information aggregator server discovery by part of the network state collectors for the same reasons explained above.

\subsubsection{Inter-server communication}
\label{ssec:multi-alto}

    A glaring gap in the working group's base ALTO protocol is its single administrative applicability domain.
    Meaning, an ALTO server is managed by a single administrative entity - likely an ISP - and its knowledge domain is limited by the network topology details that the entity wants to share.
    In the attempt to fix the server's inability to provide network status information outside its domain, this section overviews mechanisms that enable inter-server communication as a means to expand the capabilities of each domain.

    Firstly, consider how efforts for full resource synchronization could be taken.
    These would be similar to data synchronization mechanisms employed by popular databases to ensure consistency across several server replicas, and could increase availability as well as the serviceability of content nearby clients.
    However, it does not seem to fit this use case - for starters, if all data were to exist redundantly on all servers, that would defeat the purpose of having many administrative domains and thus a single server architecture would suffice; secondly, the architecture is inherently designed to work within a trust domain of selected clients, and because of it the servers may not even be comfortable with sharing all of its information within other domains to begin with, limiting replication strategies; thirdly, accounting for the amount of users acting on the ALTO system, better scalability could be achieved with a distributed solution that limits information within set boundaries.
    Accounting for these reasons, an inter-server synchronization protocol was designed for servers to negotiate information exchange among themselves.

    \textbf{[Important to note that each server must maintain administrative control over itself, thus controling who has access to what and how long that resource is accessible. It it thus unwise to create a single database that all other servers have access to. Instead, every server has an interface for other servers to enquire about, and access is granted/blocked by the server itself at any moment.]}
    \textbf{[Data resources can have a property, called "global", that dictate that a given resource is derived by sharing data from multiple ALTO servers]}
    \textbf{[There is a single central server where all ALTO servers report to, and where they advertise what information they have. If a client requests a resource to a server that isn't global and he does not possess it, he can check on this global database and redirect the user to it if he so desires, analogous to a recursive DNS query. If the resource is of global type, the ALTO server will request data to help generate the resource, and it is the result of a global connection effort. A global endpoint property map is just the joint of know key-> value pairs, whereas a cost map must require a dijkstra algorithm, for example, to derive the best choices]}
    \textbf{[Servers have an interface just for inter-server communication. ]}
    \textbf{[Communication diagrams of how inter-server synchronization works]}

\subsection{Network State Provider}

\subsubsection{Network State Collectors}

    The network information aggregation layer is the layer that enables the translation of raw topological information - such as the physical attributes of network devices and connections - into processed, query-eligible network knowledge.
    To do so, a very important entity, perhaps the heart of the system as a whole, is the network state provider, which is the supply of network information that is injected, through a network state provisioning protocol, into a network information aggregator.
    This latter entity is then responsible for providing the ALTO resource provider layer with valid information after the raw topological data has been processed - this includes the calculation of optimal paths, the abstraction of network entities, or the injection of static ISP preferences.
    This pre-processing stage requires input from an ISP administrator, responsible for acting on the best interest of the ISP from which the raw topological data originates - by interacting with the network information aggregator, the administrator acts on this network information hub to retrieve from the database a history of retrieved network information, and afterwards manipulate this information to create ALTO resources to its liking - this is where data is transformed utilizing the algorithms the administrator deems fitting, and transforms the raw data to be publishing ready, meaning that it contains an acceptable amount of abstraction not to compromise topological privacy.
    Finally, the administrator defines important meta data that identifies the resource, and defines the access control list to be enforced by the ALTO server.

\subsubsection{Network State Aggregator}

    Before ALTO resources are provided into the ALTO server by the Network Information Aggregator, the latter needs himself to be provided with raw network status information.
    The ALTO working group has discussed possible sources of raw topological information, including protocols like IGP, BGP, SNMP, or NETCONF, or databases like the Traffic Engineering Database (TED) or Label Switched Path Database (LSPD) \cite{alto-deployment-considerations}.
    A protocol needs to exist to interface between the entities that collect and provide the raw topological data, and the Network Information Aggregator that processes it and provides it to the ALTO server.

\begin{table}[]
\resizebox{\textwidth}{!}{\begin{tabular}{|l|l|l|}
\hline
\bf{HTTP Verb}  & \bf{Resource}                      & \bf{Description}                                               \\ \hline
POST            & /measurements/endpoint             & Add a measured endpoint property value                         \\ \hline
PUT             & /measurements/endpoint/\{id\}      & Modify the contents of a measured endpoint property value      \\ \hline
DELETE          & /measurements/endpoint/\{id\}      & Remove a measured endpoint property value                      \\ \hline
POST            & /measurements/links                & Add a measured link value                                      \\ \hline
PUT             & /measurements/links/\{id\}         & Modify the contents of a measured link value                   \\ \hline
DELETE          & /measurements/links/\{id\}         & Remove a measured link value                                   \\ \hline
POST            & /measurements/group                & Add a measured endpoint grouping                               \\ \hline
PUT             & /measurements/group/\{id\}         & Modify the contents a measured endpoint grouping               \\ \hline
DELETE          & /measurements/group/\{id\}         & Remove a measured endpoint grouping                            \\ \hline
\end{tabular}}
\end{table}


\begin{figure}[!h]
        \centering
        \includegraphics[scale=0.3]{img/info-provisioning-providers.png}
        \caption{Communication diagram of how external network state providers upload information to the network information aggregator}
        \label{fig:provisioning-providers}
\end{figure}


    \textbf{[Network is provided raw, as is, without validation, but validation modules could be provided in the future if a need for it exists. The uploaded information firstly has meta data - which includes the source name (where the data came from, such as an OSPF collector daemon), the time where the measurements were collected, a description, an endpoint or group of endpoints, depending on what the measurement relates to - such as an endpoint property or a cost between two properties or a grouping between N properties, and the measurement itself.]}


\subsubsection{Network Status processing}

    \textbf{[Detail how the ISP uses the information gathered by the network state providers and pre-processes it. This includes, for example, calculating shortest path maps utilizing a Dijkstra algorithm, limiting/changing information to maintain security, adding static ISP policies, and attributing access control policies for that resource]}

\begin{figure}[!h]
        \centering
        \includegraphics[scale=0.3]{img/info-provisioning-isp.png}
        \caption{Communication diagram of how an ISP administrator pre-processes the gathered network state and uploads it to the ALTO server}
        \label{fig:provisioning-isp}
\end{figure}

